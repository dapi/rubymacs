<?xml version="1.0" encoding="iso-2022-jp" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<title>irbsh - IRB.extend ShellUtilities</title>
<meta http-equiv="Content-type" content="text/html; charset=iso-2022-jp" />
<!-- head-element:nil -->
</head>
<body>
<h2>Index</h2>

<ul>
<li><a href="#label:4">About irbsh</a></li>
<li><a href="#label:5">How is irbsh better than inferior-ruby</a></li>
<li><a href="#label:6">What's new</a></li>
<li><a href="#label:10">Download</a></li>
<li><p><a href="#label:11">Install</a></p>
<ul>
<li><a href="#label:12">Irb on Windows</a></li>
</ul></li>
<li><a href="#label:13">Invoke irbsh</a></li>
<li><p><a href="#label:14">How to use</a></p>
<ul>
<li><a href="#label:15">Command-line stack</a></li>
<li><a href="#label:16">Load Ruby script</a></li>
<li><a href="#label:17">Multiple irbsh</a></li>
<li><a href="#label:18">Call irbsh from the buffer currently edited</a></li>
<li><a href="#label:19">Reboot irbsh</a></li>
<li><a href="#label:20">Extended commands</a></li>
<li><a href="#label:29">Delete `,' at the end of line</a></li>
<li><a href="#label:30">Output to kill-ring</a></li>
<li><a href="#label:31">Erase Output</a></li>
<li><a href="#label:32">Jump to previous/next prompt</a></li>
<li><a href="#label:33">Auto Quotation</a></li>
<li><a href="#label:34">Easy Method Definition</a></li>
</ul></li>
<li><p><a href="#label:35">Terminator</a></p>
<ul>
<li><a href="#label:36">`:' Disable output</a></li>
<li><a href="#label:37">`|' Redirect output</a></li>
<li><a href="#label:38">`&amp;' Background Shell</a></li>
</ul></li>
<li><p><a href="#label:39">As a command shell</a></p>
<ul>
<li><a href="#label:40">Executing shell commands</a></li>
<li><a href="#label:41">irbsh_system</a></li>
<li><a href="#label:42">Changing current directory</a></li>
<li><a href="#label:43">Command History</a></li>
</ul></li>
<li><p><a href="#label:44">Special Features</a></p>
<ul>
<li><a href="#label:45">Dry run</a></li>
<li><a href="#label:46">Execute Ruby methods without quotations</a></li>
<li><a href="#label:47">History Menu</a></li>
<li><p><a href="#label:48">Meta Variables</a></p>
<ul>
<li><a href="#label:49">Emacs Buffers as File Objects (read only)</a></li>
<li><a href="#label:50">Regions as File Objects</a></li>
</ul></li>
<li><a href="#label:51">Eval EmacsLisp sexps</a></li>
<li><a href="#label:52">Editing objects with YAML</a></li>
</ul></li>
<li><p><a href="#label:53">Completion</a></p>
<ul>
<li><a href="#label:54">Completion Examples</a></li>
</ul></li>
<li><p><a href="#label:55">Multi-line buffer</a></p>
<ul>
<li><a href="#label:56">Multi-line buffer history</a></li>
<li><a href="#label:57">Key binding of multi-line buffer</a></li>
</ul></li>
<li><a href="#label:63">Irbsh Builtin Commands</a></li>
<li><p><a href="#label:73">Eval List</a></p>
<ul>
<li><a href="#label:74">*ruby scratch* buffer</a></li>
<li><a href="#label:75">Any ruby-mode buffer</a></li>
<li><a href="#label:76">Error jump with eval list</a></li>
<li><a href="#label:77">Load the script buffer only</a></li>
<li><a href="#label:78">$IRBSH global variable</a></li>
</ul></li>
<li><a href="#label:79">Oneliner</a></li>
<li><p><a href="#label:80">.irbshrc</a></p>
<ul>
<li><a href="#label:81">Shell Aliases</a></li>
<li><a href="#label:82">Prompt Customize</a></li>
<li><a href="#label:83">pushdignoredups</a></li>
<li><a href="#label:84">systemecho</a></li>
</ul></li>
<li><a href="#label:85">License</a></li>
</ul>
<hr />

<h1><a name="Title:" href="#Title:">Title:</a> <a name="label:0">irbsh - IRB.extend ShellUtilities</a></h1><!-- RDLabel: "irbsh - IRB.extend ShellUtilities" -->

<p>$Id: irbsh.en.rd.r 1349 2006-08-22 07:40:53Z rubikitch $</p>
<dl>
<dt><a name="label:1" id="label:1"></a>author</dt><!-- RDLabel: "author" -->
<dd>
<p>rubikitch&lt;rubikitch@ruby-lang.org&gt;</p>
</dd>
<dt><a name="label:2" id="label:2"></a>irbsh official site</dt><!-- RDLabel: "irbsh official site" -->
<dd>
<p><a href="http://www.ruby-lang.org/~rubikitch/computer/irbsh/">&lt;URL:http://www.ruby-lang.org/~rubikitch/computer/irbsh/&gt;</a></p>
</dd>
<dt><a name="label:3" id="label:3"></a>screenshot</dt><!-- RDLabel: "screenshot" -->
<dd>
<ul>
<li><a href="irbsh.jpg">ScreenShot</a></li>
<li><a href="irbsh-history.jpg">History Menu</a></li>
<li><a href="eval-list.jpg">Eval List</a></li>
<li><a href="bg.jpg">Background Shell</a></li>
</ul>
</dd>
</dl>
<h2><a name="1" href="#1">1</a> <a name="label:4">About irbsh</a></h2><!-- RDLabel: "About irbsh" -->

<p>Irbsh is an extension of irb/inf-ruby.el.
You can easily execute shell commands and Ruby codes by using irbsh.</p>
<p>Eval list feature makes irbsh be an development environment of Ruby.</p>
<p>While irbsh has many features, you can use easily.</p>
<h2><a name="2" href="#2">2</a> <a name="label:5">How is irbsh better than inferior-ruby</a></h2><!-- RDLabel: "How is irbsh better than inferior-ruby" -->

<ul>
<li><p>Irbsh interprets command-line beginning from ' ' as shell command.</p>
<ul>
<li>You can use Ruby's #{...} expansion.</li>
<li>It displays what command is executing.</li>
<li>It displays return status.</li>
</ul></li>
<li>Like shell-mode irbsh follows current-directory.</li>
<li>You can insert 'system' method by two strokes.</li>
<li>You can change the context (shell-command/Ruby-statement) by one stroke.</li>
<li>If (command-line =~ /;$/) then irbsh disables output.</li>
<li>If (command-line =~ /\|$/) then irbsh redirects output to another buffer.</li>
<li>If (command-line =~ /&amp;$/) then irbsh uses background shell or GNU screen.</li>
<li><p>Intelligent completion.</p>
<ul>
<li>buffer-name, shell-commands, file/directory-names, method/variable-names.</li>
</ul></li>
<li>Zsh-like command-line stack.</li>
<li>Zsh-like wildcard expansion.</li>
<li>You can load any Ruby scripts.</li>
<li>You can call irbsh from any buffers.</li>
<li>You can handle Emacs-region and Emacs-buffer as File object.</li>
<li>Keybind is like shell at terminal.</li>
<li>You can <a href="#label:31">Erase Output</a> and prompt when you execute wrong command-line.</li>
<li><a href="#label:55">Multi-line buffer</a> enables you to write multi-line input.</li>
<li><a href="#label:73">Eval List</a> executes pre-registered expressions.</li>
<li><a href="#label:74">*ruby scratch* buffer</a> is a scratch buffer for Ruby.</li>
<li><a href="#label:79">Oneliner</a> enables you to execute a Ruby expression any time.</li>
<li>You can <a href="#label:52">edit objects with YAML</a>.</li>
<li>You can eval any EmacsLisp expressions.</li>
<li><a href="#label:34">Easy Method Definition</a></li>
</ul>
<h2><a name="3" href="#3">3</a> <a name="label:6">What's new</a></h2><!-- RDLabel: "What's new" -->

<dl>
<dt><a name="label:7" id="label:7"></a>[2010/04/08] Ver 1.0.1</dt><!-- RDLabel: "[2010/04/08] Ver 1.0.1" -->
<dd>
<ul>
<li>Fix a display bug in irbsh.el</li>
<li>Ruby 1.9 compliant</li>
</ul>
</dd>
<dt><a name="label:8" id="label:8"></a>[2006/01/16] Ver 1.0.0</dt><!-- RDLabel: "[2006/01/16] Ver 1.0.0" -->
<dd>
<ul>
<li>EmacsLisp sexp evaluation</li>
<li>Edit objects</li>
<li>English document</li>
<li>irbsh-toggle.el</li>
<li>many bugfixes</li>
<li>Easy Method Definition</li>
</ul>
</dd>
<dt><a name="label:9" id="label:9"></a>[2001/11/15] Ver 0.1</dt><!-- RDLabel: "[2001/11/15] Ver 0.1" -->
<dd>
<p>Initial release</p>
</dd>
</dl>
<h2><a name="4" href="#4">4</a> <a name="label:10">Download</a></h2><!-- RDLabel: "Download" -->

<p>You can download irbsh from <a href="http://raa.ruby-lang.org/list.rhtml?name=irbsh">[RAA:irbsh]</a>.</p>
<h2><a name="5" href="#5">5</a> <a name="label:11">Install</a></h2><!-- RDLabel: "Install" -->

<ol>
<li>Install Ruby and inf-ruby.el.</li>
<li><p>Install by setup.rb.</p>
<pre>$ ruby setup.rb config
$ ruby setup.rb setup
# ruby setup.rb install</pre></li>
<li><p>Append the following to .irbrc</p>
<pre>load "irbsh-lib.rb" if IRB.conf[:PROMPT_MODE] == :INF_RUBY</pre></li>
<li><p>Append the following to .emacs</p>
<pre>(load "irbsh")
(load "irbsh-toggle")</pre></li>
</ol>
<pre>or
    (when (locate-library "irbsh")
      (autoload 'irbsh "irbsh" "irbsh - IRB.extend ShellUtilities" t)
      (autoload 'irbsh-oneliner-with-completion "irbsh" "irbsh oneliner" t))
    (when (locate-library "irbsh-toggle")
      (autoload 'irbsh-toggle "irbsh-toggle" 
        "Toggles between the *irbsh*1 buffer and whatever buffer you are editing."
      t)
      (autoload 'irbsh-toggle-cd "irbsh-toggle" 
        "Pops up a irbsh-buffer and insert a "cd &lt;file-dir&gt;" command." t))

  If you see
    (file-error "Cannot open load file" "irbsh")
  error message, you append       
    (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/")</pre>
<h3><a name="5.1" href="#5.1">5.1</a> <a name="label:12">Irb on Windows</a></h3><!-- RDLabel: "Irb on Windows" -->

<p>Use this setting on Windows.</p>
<pre>(setq ruby-program-name "ruby -S irb --inf-ruby-mode")</pre>
<h2><a name="6" href="#6">6</a> <a name="label:13">Invoke irbsh</a></h2><!-- RDLabel: "Invoke irbsh" -->

<pre>M-x irbsh</pre>
<p>You can see irb prompt.</p>
<h2><a name="7" href="#7">7</a> <a name="label:14">How to use</a></h2><!-- RDLabel: "How to use" -->

<h3><a name="7.1" href="#7.1">7.1</a> <a name="label:15">Command-line stack</a></h3><!-- RDLabel: "Command-line stack" -->

<p>Irbsh has zsh-like command-line stack.
Those who are using zsh will explain here once, although you may fly.</p>
<p>For example:</p>
<p>You want to copy file, so you typed the following.(1)</p>
<pre>#(1)
[pwd:~]
irbsh(main):001:0&gt; File::cp File::expand_path("~/.emacs"), "/tmp"</pre>
<p>OOPS! You forgot to type require statement.
Be quiet, irbsh resques you.
Type `M-q', and the command-line is disappearred.(2)</p>
<pre>#(2)
[pwd:~]
irbsh(main):001:0&gt; </pre>
<p>You cool it, and type require statement.(3)</p>
<pre>#(3)
[pwd:~]
irbsh(main):001:0&gt; require 'ftools'</pre>
<p>OH! The command-line typed past is returned.(4)</p>
<pre>#(4)
irbsh(main):001:0&gt; require 'ftools'
true
[pwd:~]
irbsh(main):002:0&gt; File::cp File::expand_path("~/.emacs"), "/tmp"</pre>
<p>You come to a happy end.
Push Enter and irbsh executes file copy.(5)</p>
<pre>#(5)
irbsh(main):001:0&gt; require 'ftools'
true
irbsh(main):002:0&gt; File::cp File::expand_path("~/.emacs"), "/tmp"
true
[pwd:~]
irbsh(main):003:0&gt; </pre>
<p>In addition, since the command line stack function is separated with `irbsh', `shell-mode' and `ielm-mode' can also be used.</p>
<h3><a name="7.2" href="#7.2">7.2</a> <a name="label:16">Load Ruby script</a></h3><!-- RDLabel: "Load Ruby script" -->

<p>If C-cC-f is pushed, the following is displayed in Emacs echo-area.</p>
<pre>Load file: ~/</pre>
<p>Type the filename of Ruby script.</p>
<p>For example, the filename is ~/.irbrc, the following statement is inserted.</p>
<pre>irbsh(main):010:0&gt; load '/home/rubikitch/.irbrc'</pre>
<p>inf-ruby.el although `ruby-load-file' also carries out equivalent work.
Since a load sentence is specified, it turns out that it was loaded.</p>
<h3><a name="7.3" href="#7.3">7.3</a> <a name="label:17">Multiple irbsh</a></h3><!-- RDLabel: "Multiple irbsh" -->

<p>Irbsh of another process is started by `C-cC-s'.
As for the buffer name, the number is added sequentially from 1 after *irbsh*.
It will be useful when working with other current directories.</p>
<p>Typing C-c 1 .. C-c 9 switches to the corresponding *irbsh* buffer.</p>
<h3><a name="7.4" href="#7.4">7.4</a> <a name="label:18">Call irbsh from the buffer currently edited</a></h3><!-- RDLabel: "Call irbsh from the buffer currently edited" -->

<p>Irbsh can be called from arbitrary buffers by typing `M-x goto-irbsh'. 
New irbsh is started while each *irbsh* buffers which exist now are using it.
When the cursor of a *irbsh* buffer does not point the command line, that *irbsh* buffer is USED.</p>
<p>Typing</p>
<pre>M-x irbsh-toggle</pre>
<p>pops up *irbsh*1 buffer.
In *irbsh*1 buffer, irbsh-toggle restores the window configuration before calling up *irbsh*1 buffer.</p>
<h3><a name="7.5" href="#7.5">7.5</a> <a name="label:19">Reboot irbsh</a></h3><!-- RDLabel: "Reboot irbsh" -->

<p>Irbsh is rebooted by typing `M-x irbsh-restart'.
i.e., the present irb process is killed, and rebooted.
Since the contents of current buffer are lost , it is careful.</p>
<h3><a name="7.6" href="#7.6">7.6</a> <a name="label:20">Extended commands</a></h3><!-- RDLabel: "Extended commands" -->

<p>When variable `irbsh-use-sigle-key-extension-flag' is t, operation of C-w, C-u, C-d, C-k, etc. will be extended. With a default It is t.</p>
<p>Respectively, the action on a command line changes, and it is ordinary operation when that is not on a command line.</p>
<dl>
<dt><a name="label:21" id="label:21"></a>C-w</dt><!-- RDLabel: "C-w" -->
<dd>
<p>1 word deletion.</p>
</dd>
<dt><a name="label:22" id="label:22"></a>C-u</dt><!-- RDLabel: "C-u" -->
<dd>
<p>All deletion about the line of a command line.</p>
</dd>
<dt><a name="label:23" id="label:23"></a>C-d</dt><!-- RDLabel: "C-d" -->
<dd>
<p>When it is in the tail end of a command line `'',' is inserted.</p>
</dd>
<dt><a name="label:24" id="label:24"></a>C-k</dt><!-- RDLabel: "C-k" -->
<dd>
<p>When it is in the tail end of a command line, toggles the top space.
The context of the command line is changed.
Whether it interprets as a sentence of Ruby or it interprets as a shell command change.
After inputting a command, when it thinks, "This is a shell command", it will not waver but I will push this!</p>
</dd>
<dt><a name="label:25" id="label:25"></a>C-o</dt><!-- RDLabel: "C-o" -->
<dd>
<p>The same effect as `C-p C-w'.
Convenient to perform the same command/method by other arguments.</p>
</dd>
<dt><a name="label:26" id="label:26"></a>C-p</dt><!-- RDLabel: "C-p" -->
<dd>
<p>The contents of the last command line are taken out.
It is the same as M-p.</p>
</dd>
<dt><a name="label:27" id="label:27"></a>C-n</dt><!-- RDLabel: "C-n" -->
<dd>
<p>The contents of the following command line are taken out.
It is the same as M-n.</p>
</dd>
<dt><a name="label:28" id="label:28"></a>C-v</dt><!-- RDLabel: "C-v" -->
<dd>
<p>Opening <a href="#label:47">History Menu</a>.</p>
</dd>
</dl>
<h3><a name="7.7" href="#7.7">7.7</a> <a name="label:29">Delete `,' at the end of line</a></h3><!-- RDLabel: "Delete `,' at the end of line" -->

<p>Using C-d will remain `,' at the end of line.
If `irbsh-strip-last-comma-flag' is t,  typing Enter deletes `,' at the EOL.
Default value is t.</p>
<pre>Therefore, it is not necessary to delete by hand purposely.

 puts  C-d abc
 irbsh(main):083:0&gt; puts 'abc',
 Typing Enter...
 irbsh(main):083:0&gt; puts 'abc'
 abc
 nil</pre>
<h3><a name="7.8" href="#7.8">7.8</a> <a name="label:30">Output to kill-ring</a></h3><!-- RDLabel: "Output to kill-ring" -->

<p>Typing C-c C-k stores previous output to kill-ring.</p>
<h3><a name="7.9" href="#7.9">7.9</a> <a name="label:31">Erase Output</a></h3><!-- RDLabel: "Erase Output" -->

<p>Typing C-c C-q erases previous prompt and output.
It is useful if you execute wrong command line.</p>
<p>C-c C-o, standard comint command, erases previous output only.</p>
<pre>irbsh(*SHELL*):061:0&gt;  ls ~/.eamcs
~ $ ls ~/.eamcs
ls: /home/rubikitch/.eamcs: No such file or directory
[pwd:~] (status = 256)
irbsh(main):062:0&gt; 
Typing C-c C-q
irbsh(main):062:0&gt; 
Re-entering right input
irbsh(*SHELL*):062:0&gt;  ls ~/.emacs
~ $ ls ~/.emacs
/home/rubikitch/.emacs
[pwd:~] (status = 0)
irbsh(main):063:0&gt; 
Typing C-c C-o
irbsh(*SHELL*):062:0&gt;  ls ~/.emacs
*** output flushed ***
irbsh(main):063:0&gt; </pre>
<h3><a name="7.10" href="#7.10">7.10</a> <a name="label:32">Jump to previous/next prompt</a></h3><!-- RDLabel: "Jump to previous/next prompt" -->

<p>C-c C-p / C-c C-n jump previous/next prompt.</p>
<h3><a name="7.11" href="#7.11">7.11</a> <a name="label:33">Auto Quotation</a></h3><!-- RDLabel: "Auto Quotation" -->

<p>C-c (, C-c {, C-c [, C-c ', C-c " prepare parenthesis.</p>
<h3><a name="7.12" href="#7.12">7.12</a> <a name="label:34">Easy Method Definition</a></h3><!-- RDLabel: "Easy Method Definition" -->

<p>Irbsh provides special syntax of method definition.</p>
<pre>method_name (arguments) definition</pre>
<p>This syntax is only accepted in the command line.</p>
<p>This syntax internally uses Module#define_method, so you can define a method containing local variables of current binding.</p>
<pre>irbsh[17@09:10](main):015:0&gt; one () 1
#&lt;Proc:0xb7984740@(irbsh):15&gt;
irbsh[17@09:10](main):016:0&gt; two = 2
2
irbsh[17@09:10](main):017:0&gt; three_times (x) x*(one+two)
#&lt;Proc:0xb7978b84@(irbsh):17&gt;
irbsh[17@09:10](main):018:0&gt; three_times 10
30</pre>
<p>Special syntax `defun' defines multi-line definition of method.</p>
<pre>irbsh[17@09:12](main):022:0&gt; defun four()
                               two+two
                             end
#&lt;Proc:0xb795abd4@(irbsh):22&gt;
irbsh[17@09:13](main):025:0&gt; four
4</pre>
<h2><a name="8" href="#8">8</a> <a name="label:35">Terminator</a></h2><!-- RDLabel: "Terminator" -->

<h3><a name="8.1" href="#8.1">8.1</a> <a name="label:36">`:' Disable output</a></h3><!-- RDLabel: "`:' Disable output" -->

<p>If the command line is terminated by `:', irbsh does not display output.</p>
<pre>irbsh(main):008:0&gt; Array.new 1000
[nil, nil, nil...]
irbsh(main):009:0&gt; Array.new 1000;
[pwd:/tmp] (Output is disabled.)
irbsh(main):010:0&gt; </pre>
<p>It is almost the same functionality as that of MATLAB.</p>
<h3><a name="8.2" href="#8.2">8.2</a> <a name="label:37">`|' Redirect output</a></h3><!-- RDLabel: "`|' Redirect output" -->

<p>If the command line is terminated by `|', the output is saved into *irbsh output* buffer, specified by `irbsh-redirect-output-buffer'.</p>
<pre>irbsh(main):009:0&gt; Array.new(3)|
output is at #&lt;buffer *irbsh output*&gt;
irbsh(*SHELL*):010:0&gt;  ls ~/.emacs|
output is at #&lt;buffer *irbsh output*&gt;</pre>
<p>If `irbsh-display-redirect-output-buffer-flag' is t, default is nil, the output buffer is popped up.</p>
<h3><a name="8.3" href="#8.3">8.3</a> <a name="label:38">`&amp;' Background Shell</a></h3><!-- RDLabel: "`&' Background Shell" -->

<p>Just the same as Unix shells, if the command line is terminated by `&amp;', the command is executed in the background.
This terminator is valid in the shell context.</p>
<pre>irbsh[29@07:58](*SHELL*):062:0&gt;  ls &amp;
background process at #&lt;buffer *ls*&gt;</pre>
<p>In this example, the output is saved into *ls* buffer, whose major-mode is irbsh-background-shell-mode derived by shell-mode.
The main differences are</p>
<ul>
<li>No shell prompts.</li>
<li><p>When the process is terminated (like GNU Screen's zombie feature)</p>
<ul>
<li>typing `q' kills buffer.</li>
<li>typing Enter redoes the command.</li>
</ul></li>
</ul>
<p>If `irbsh-use-screen' is t, irbsh uses GNU Screen instead of background shell.  </p>
<h2><a name="9" href="#9">9</a> <a name="label:39">As a command shell</a></h2><!-- RDLabel: "As a command shell" -->

<h3><a name="9.1" href="#9.1">9.1</a> <a name="label:40">Executing shell commands</a></h3><!-- RDLabel: "Executing shell commands" -->

<p>In irbsh command line, an input matching /^ / is treated as shell command.
Irbsh displays the CONTEXT at the prompt.</p>
<pre>irbsh(*SHELL*):048:0&gt;  pwd
~ $ pwd
/home/rubikitch
irbsh(main):049:0&gt; a = 1
1
irbsh(*SHELL*):050:0&gt;  echo #{a}
~ $ echo 1
1
[pwd:~] (status = 0)</pre>
<h3><a name="9.2" href="#9.2">9.2</a> <a name="label:41">irbsh_system</a></h3><!-- RDLabel: "irbsh_system" -->

<p>To execute shell commands with Ruby control structures, use `irbsh_system' method.
For convenience irbsh prepares shortcut.
Typing C-c C-m inserts `irbsh_system' method in the command line.</p>
<pre>irbsh(main):039:0&gt; irbsh_system %Q[pwd]
~/src/irbsh $ pwd
/home/rubikitch/src/irbsh
[pwd:~/src/irbsh] (status = 0)

irbsh(main):004:0&gt; (1..5).each {|i| irbsh_system %Q[echo #{i}]}
~ $ echo 1
1
~ $ echo 2
2
~ $ echo 3
3
~ $ echo 4
4
~ $ echo 5
5
[pwd:~] (status = 0)</pre>
<h3><a name="9.3" href="#9.3">9.3</a> <a name="label:42">Changing current directory</a></h3><!-- RDLabel: "Changing current directory" -->

<p>When irbsh execute shell commands, it makes child process.
Executing `cd' in child process does not change current directory of parent process.
So when executing `cd'  in the shell context, changing current directory of irbsh.</p>
<pre>irbsh(*SHELL*):006:0&gt;  cd
"~"
irbsh(*SHELL*):007:0&gt;  cd /tmp
"/tmp"
[pwd:/tmp]</pre>
<h3><a name="9.4" href="#9.4">9.4</a> <a name="label:43">Command History</a></h3><!-- RDLabel: "Command History" -->

<p>Irbsh implements command history.
Irbsh records inputs into `~/.irbsh_history', which is specified by `irbsh-history-file'.
If `irbsh-history-file' is nil, irbsh does not record history.</p>
<h2><a name="10" href="#10">10</a> <a name="label:44">Special Features</a></h2><!-- RDLabel: "Special Features" -->

<h3><a name="10.1" href="#10.1">10.1</a> <a name="label:45">Dry run</a></h3><!-- RDLabel: "Dry run" -->

<p>For executing shell commands with complicated control structures, irbsh provides `dry-run feature'.
The command line is terminated by `$', shell commands are not executed.</p>
<pre>irbsh(main):019:0&gt; 3.times { irbsh_system %Q[echo 123] }$
~/emacs(dryrun) $ echo 123
~/emacs(dryrun) $ echo 123
~/emacs(dryrun) $ echo 123
3
[pwd:~/emacs]

irbsh(main):020:0&gt; 3.times { irbsh_system %Q[echo 123] }
~/emacs $ echo 123
123
~/emacs $ echo 123
123
~/emacs $ echo 123
123
[pwd:~/emacs] (status = 0)</pre>
<h3><a name="10.2" href="#10.2">10.2</a> <a name="label:46">Execute Ruby methods without quotations</a></h3><!-- RDLabel: "Execute Ruby methods without quotations" -->

<p>Irbsh can execute Ruby methods without quotations by defining methods whose name match /^nq_/.
When passing arguments to nq_xxx method, the command line is splitted by spaces.
The example below shows how to pass arguments.
Note that <a href="http://www.rubyist.net/~rubikitch/computer/ppp/">`ppp'</a> is a small library to print local variables and so on.</p>
<pre>irbsh(main):121:0&gt; require 'ppp'
true
irbsh(main):130:0&gt; def nq_f1(x); ppp :x; end
nil
irbsh(main):132:0&gt; def nq_f2(x,y); ppp :x, :y; end
nil
irbsh(main):134:0&gt; def nq_f3(x,*y); ppp :x,:y; end
nil
irbsh(main):135:0&gt; def nq_f4(x,y,*z);ppp :x,:y,:z; end
nil
irbsh(main):148:0&gt; method(:nq_f1).arity
1
irbsh(main):149:0&gt; method(:nq_f2).arity
2
irbsh(main):150:0&gt; method(:nq_f3).arity
-2
irbsh(main):151:0&gt; method(:nq_f4).arity
-3
irbsh(main):139:0&gt;  f1 1 2 3 4 5
x = "1 2 3 4 5"
[:x]
irbsh(main):140:0&gt;  f2 1 2 3 4 5
x = "1"
y = "2 3 4 5"
[:x, :y]
irbsh(main):141:0&gt;  f3 1 2 3 4 5
x = "1"
y = ["2", "3", "4", "5"]
[:x, :y]
irbsh(main):144:0&gt;  f4 1 2 3 4 5
x = "1"
y = "2"
z = ["3", "4", "5"]
[:x, :y, :z]</pre>
<h3><a name="10.3" href="#10.3">10.3</a> <a name="label:47">History Menu</a></h3><!-- RDLabel: "History Menu" -->

<p>Irbsh provides history menu feature to paste previously input command line.
Typing C-v on the command line pops up *irbsh history* buffer containing previously input command lines.
Then select the history by typing a character before `:'.
To close the history menu, type C-v or `0'.</p>
<p>When the history menu is displaying, typing C-s and search query shows history which match the query. (history menu grep)</p>
<h3><a name="10.4" href="#10.4">10.4</a> <a name="label:48">Meta Variables</a></h3><!-- RDLabel: "Meta Variables" -->

<p>To communicate irbsh and Emacs, there are meta variables.</p>
<h4><a name="10.4.1" href="#10.4.1">10.4.1</a> <a name="label:49">Emacs Buffers as File Objects (read only)</a></h4><!-- RDLabel: "Emacs Buffers as File Objects (read only)" -->

<p>When you want to use buffer contents in irbsh, use</p>
<p>`---BUFFER NAME---'</p>
<p>meta variable.
When irbsh finds this meta variable, the contents of buffer at this time is saved into temporary file and you can treat it as a File object.</p>
<p>For example, the contents of the *scratch* buffer is the following.</p>
<pre>;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.</pre>
<p>And the irbsh session,</p>
<pre>irbsh(main):063:0&gt; scratch = ---*scratch*---
#&lt;File:0x401938a0&gt;
irbsh(main):064:0&gt; scratch.class
File
irbsh(main):065:0&gt; scratch.path
"/tmp/irbshtmp4964wnC"
irbsh(main):066:0&gt; s = scratch.read
";; This buffer is for notes you don't want to save, and for Lisp evaluation.\n;; If you want to create a file, visit that file with C-x C-f,\n;; then enter the text in that file's own buffer.\n"
irbsh(main):067:0&gt; ni
;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.
irbsh(main):068:0&gt; s.grep(/save/)
[";; This buffer is for notes you don't want to save, and for Lisp evaluation.\n"]</pre>
<h4><a name="10.4.2" href="#10.4.2">10.4.2</a> <a name="label:50">Regions as File Objects</a></h4><!-- RDLabel: "Regions as File Objects" -->

<p>In addition to buffers irbsh can treat regions as File objects.</p>
<p>To use this feature,</p>
<ol>
<li>Specify the region and type M-w / C-w to store it into the kill-ring.</li>
<li>Use `__region__' meta variable in irbsh.</li>
</ol>
<pre>irbsh(main):019:0&gt; fbb = __region__
#&lt;File:0x402f62a4&gt;
irbsh(main):020:0&gt; fbb.gets
"foo bar baz"
irbsh(main):021:0&gt; fbb.rewind; fbb.read
"foo bar baz"</pre>
<h3><a name="10.5" href="#10.5">10.5</a> <a name="label:51">Eval EmacsLisp sexps</a></h3><!-- RDLabel: "Eval EmacsLisp sexps" -->

<p>Irbsh can eval EmacsLisp sexps.</p>
<pre>irbsh[13@18:30](*SHELL*):010:0&gt;  el (setq a 2)
2
nil
irbsh[13@18:30](main):011:0&gt; EmacsLisp.el %((setq a (* 2 a))) 
4
nil</pre>
<p>It is simple implementation to realize <a href="#label:52">object editor</a>.
If you want to control Emacs in Ruby, use <a href="http://www.rubyist.net/~rubikitch/computer/el4r/">el4r</a>.
El4r enables you to write Emacs applications in Ruby.</p>
<h3><a name="10.6" href="#10.6">10.6</a> <a name="label:52">Editing objects with YAML</a></h3><!-- RDLabel: "Editing objects with YAML" -->

<p>Irbsh enables you to edit objects using YAML.</p>
<pre>irbsh[13@18:30](main):012:0&gt; s = "abcd"
"abcd"
irbsh[13@18:38](main):013:0&gt; s.edit
"editing object..."
"ABCD"</pre>
<p>When you execute</p>
<pre>s.edit</pre>
<p>then irbsh pops up a buffer containing the YAML representation of `s'.
After editing the object, type C-c C-c to exit.</p>
<h2><a name="11" href="#11">11</a> <a name="label:53">Completion</a></h2><!-- RDLabel: "Completion" -->

<p>One of the main features of irbsh is intelligent completion.</p>
<ul>
<li><p>common</p>
<ul>
<li>file name completion</li>
<li>directory name of previous string</li>
<li>directory name completion of `cd'</li>
<li>wildcard expansion</li>
<li>home directory expansion</li>
</ul></li>
<li><p>Shell context</p>
<ul>
<li>command name completion</li>
<li>file name completion</li>
<li>directory name of previous string</li>
</ul></li>
<li><p>Ruby context</p>
<ul>
<li>buffer name completion of `---BUFFERNAME---'</li>
<li>method / variable name completion</li>
</ul></li>
</ul>
<h3><a name="11.1" href="#11.1">11.1</a> <a name="label:54">Completion Examples</a></h3><!-- RDLabel: "Completion Examples" -->

<pre>irbsh(*SHELL*):076:0&gt;  dpkg-bu
typing TAB
irbsh(*SHELL*):076:0&gt;  dpkg-buildpackage 

irbsh(*SHELL*):026:0&gt;  ls =modpro
typing TAB
irbsh(*SHELL*):026:0&gt;  ls =modprobe 

irbsh(*SHELL*):077:0&gt;  cat .zpro
typing TAB
irbsh(*SHELL*):077:0&gt;  cat .zprofile

irbsh(*SHELL*):077:0&gt;  cat .zprofile compi
typing TAB
irbsh(*SHELL*):077:0&gt;  cat .zprofile compile/

irbsh(*SHELL*):077:0&gt;  cat .zprofile compile/hog
typing TAB
irbsh(*SHELL*):077:0&gt;  cat .zprofile compile/hoge 

typing puts C-d .zpro
irbsh(main):022:0&gt; puts '.zpro',
typing TAB
irbsh(main):022:0&gt; puts '.zprofile',
typing C-e
irbsh(main):022:0&gt; puts '.zprofile',
typing C-d
irbsh(main):022:0&gt; puts '.zprofile','',
typing compi 
irbsh(main):022:0&gt; puts '.zprofile','compi',
typing TAB
irbsh(main):022:0&gt; puts '.zprofile','compile/',

irbsh(main):022:0&gt; puts '.zprofile','compile/hoge',
typing Enter 
irbsh(main):022:0&gt; puts '.zprofile','compile/hoge'

irbsh(*SHELL*):091:0&gt;  echo compi
typing TAB
irbsh(*SHELL*):091:0&gt;  echo compile/
typing foo SPC
irbsh(*SHELL*):091:0&gt;  echo compile/foo 
typing TAB
irbsh(*SHELL*):091:0&gt;  echo compile/foo compile/
typing ba TAB
irbsh(*SHELL*):091:0&gt;  echo compile/foo compile/bar 

typing puts C-d compi
irbsh(main):091:0&gt; puts 'compi',
typing TAB
irbsh(main):091:0&gt; puts 'compile/',
typing fo TAB
irbsh(main):091:0&gt; puts 'compile/foo',
typing C-e
irbsh(main):091:0&gt; puts 'compile/foo',
typing TAB
irbsh(main):091:0&gt; puts 'compile/foo','compile/',
typing ba TAB
irbsh(main):091:0&gt; puts 'compile/foo','compile/bar',
typing Enter
irbsh(main):091:0&gt; puts 'compile/foo','compile/bar'

irbsh(*SHELL*):032:0&gt;  ls
~/src/irbsh $ ls
GPL                  comint-redirect.el   irbsh.el                     irbsh.ja.html
Makefile          comint-util.el       irbsh.elc             irbsh.ja.rd
RCS                  irbsh-completion.rb  irbsh.ja.hindex.html
cmdline-stack.el  irbsh-lib.rb               irbsh.ja.hindex.rd
[pwd:~/src/irbsh] (status = 0)
irbsh(*SHELL*):033:0&gt;  ls *.el
typing TAB
irbsh(*SHELL*):033:0&gt;  ls cmdline-stack.el irbsh.el comint-redirect.el comint-util.el 


irbsh(*SHELL*):033:0&gt;  ls {GPL,RCS}
typing TAB
irbsh(*SHELL*):033:0&gt;  ls GPL RCS 

cursor is after `~'
irbsh[12:47](main):027:0&gt; open '~',
typing TAB  
irbsh[12:47](main):027:0&gt; open '/home/rubikitch',


cursor is after `/'
irbsh[12:47](main):027:0&gt; open '~/',
typing TAB
irbsh[12:47](main):027:0&gt; open '/home/rubikitch/',

typing scratch = ---*
irbsh(main):089:0&gt; scratch = ---*
typing scr
irbsh(main):089:0&gt; scratch = ---*scr
typing TAB
irbsh(main):089:0&gt; scratch = ---*scratch*---</pre>
<h2><a name="12" href="#12">12</a> <a name="label:55">Multi-line buffer</a></h2><!-- RDLabel: "Multi-line buffer" -->

<p>To execute multi-line Ruby expressions, irbsh provides multi-line buffer feature.
To pop up the multi-line buffer, type C-c SPC.
If command line is not empty, irbsh pastes it into the multi-line buffer.</p>
<h3><a name="12.1" href="#12.1">12.1</a> <a name="label:56">Multi-line buffer history</a></h3><!-- RDLabel: "Multi-line buffer history" -->

<p>The multi-line buffer provides its own history.
Type M-p/M-n to recall previously input.</p>
<h3><a name="12.2" href="#12.2">12.2</a> <a name="label:57">Key binding of multi-line buffer</a></h3><!-- RDLabel: "Key binding of multi-line buffer" -->

<dl>
<dt><a name="label:58" id="label:58"></a>C-c C-c</dt><!-- RDLabel: "C-c C-c" -->
<dd>
<p>Exit the multi-line buffer and eval the contents.</p>
</dd>
<dt><a name="label:59" id="label:59"></a>C-c C-x</dt><!-- RDLabel: "C-c C-x" -->
<dd>
<p>Only eval the contents.</p>
</dd>
<dt><a name="label:60" id="label:60"></a>C-c C-q</dt><!-- RDLabel: "C-c C-q" -->
<dd>
<p>Erase previous output. Same as irbsh.</p>
</dd>
<dt><a name="label:61" id="label:61"></a>C-c C-e</dt><!-- RDLabel: "C-c C-e" -->
<dd>
<p>Erase the multi-line buffer.</p>
</dd>
<dt><a name="label:62" id="label:62"></a>M-p, M-n</dt><!-- RDLabel: "M-p, M-n" -->
<dd>
<p>History.</p>
</dd>
</dl>
<h2><a name="13" href="#13">13</a> <a name="label:63">Irbsh Builtin Commands</a></h2><!-- RDLabel: "Irbsh Builtin Commands" -->

<p>Irbsh provides some builtin commands, short name and long name.</p>
<dl>
<dt><a name="label:64" id="label:64"></a>pwd, irbsh_pwd</dt><!-- RDLabel: "pwd, irbsh_pwd" -->
<dd>
<p>Display the current directory.</p>
</dd>
<dt><a name="label:65" id="label:65"></a>cd(dir), pushd, irbsh_cd</dt><!-- RDLabel: "cd(dir), pushd, irbsh_cd" -->
<dd>
<p>Change the current directory.</p>
</dd>
<dt><a name="label:66" id="label:66"></a>popd, irbsh_popd</dt><!-- RDLabel: "popd, irbsh_popd" -->
<dd>
<p>Change the current directory to the previous one.</p>
</dd>
<dt><a name="label:67" id="label:67"></a>dirs</dt><!-- RDLabel: "dirs" -->
<dd>
<p>Print the directory stack.</p>
</dd>
<dt><a name="label:68" id="label:68"></a>ls(*argv), irbsh_ls</dt><!-- RDLabel: "ls(*argv), irbsh_ls" -->
<dd>
<p>Print the file list and return it.</p>
</dd>
<dt><a name="label:69" id="label:69"></a>ll(*argv), irbsh_ll</dt><!-- RDLabel: "ll(*argv), irbsh_ll" -->
<dd>
<p>Execute `ls -l' and return the file list.</p>
</dd>
<dt><a name="label:70" id="label:70"></a>ni, irbsh_no_inspect</dt><!-- RDLabel: "ni, irbsh_no_inspect" -->
<dd>
<p>Print the result with `to_s' (not inspect).</p>
<ul>
<li>a_object.ni</li>
<li>ni expression</li>
<li>ni { block }</li>
</ul>
</dd>
<dt><a name="label:71" id="label:71"></a>irbsh_system(cmd)</dt><!-- RDLabel: "irbsh_system(cmd)" -->
<dd>
<p>Execute in the shell context.</p>
</dd>
<dt><a name="label:72" id="label:72"></a>irbsh_alias(alias, definition)</dt><!-- RDLabel: "irbsh_alias(alias, definition)" -->
<dd>
<p>Defining <a href="#label:81">Shell Aliases</a>.</p>
</dd>
</dl>
<h2><a name="14" href="#14">14</a> <a name="label:73">Eval List</a></h2><!-- RDLabel: "Eval List" -->

<p>Another main feature is the eval list.
The eval list eases evaluation of pre-registered expressions.
If you want to eval the same expressions many times, you do not have to input the expressions in each case.</p>
<p>The eval list works with SCRIPT BUFFFER.
Script buffer means the ruby-mode buffer currently displaying.
When you EXECUTE the eval list, irbsh does</p>
<ol>
<li>save the script buffer into temporary script</li>
<li>load the temporary script</li>
<li>eval each expression in the eval list buffer</li>
</ol>
<p>Type C-c M-e to visit the eval list.
Type C-c C-z to execute the eval list.
These key binding can be used in script, irbsh and eval list buffer.</p>
<h3><a name="14.1" href="#14.1">14.1</a> <a name="label:74">*ruby scratch* buffer</a></h3><!-- RDLabel: "*ruby scratch* buffer" -->

<p>When typing C-c M-e in an irbsh buffer, split the screen into three divisions.
The upper window displays *ruby scratch* buffer.
You can write any Ruby script in the *ruby scratch* buffer.</p>
<p>Here is a sample eval list session.</p>
<pre>---- *ruby scratch*
def f(x)
  x ** 2
end

---- *irbsh eval list*
f(0)
f(1)
f(2)
f(3)
s=---*ruby scratch*---;
s.read.length</pre>
<p>Then type C-c C-z, and irbsh displays</p>
<pre>irbsh[27@16:03](main):085:0&gt; 
EvalList(main):086:0&gt; f(0)
0
EvalList(main):087:0&gt; f(1)
1
EvalList(main):088:0&gt; f(2)
4
EvalList(main):089:0&gt; f(3)
9
EvalList(main):090:0&gt; s=open( '/tmp/irbshtmp256619ew' )
(Output is disabled.)
EvalList(main):091:0&gt; s.read.length
22
EvalList(main):092:0&gt; nil</pre>
<p>Modify the script buffer.</p>
<pre>---- *ruby scratch*
def f(x)
  x ** 3
end</pre>
<p>Then type C-c C-z,  </p>
<pre>irbsh[27@16:36](main):090:0&gt; 
EvalList(main):091:0&gt; f(0)
0
EvalList(main):092:0&gt; f(1)
1
EvalList(main):093:0&gt; f(2)
8
EvalList(main):094:0&gt; f(3)
27
EvalList(main):095:0&gt; nil</pre>
<p>You do not have to save buffers!</p>
<p>If you scroll irbsh buffer in the eval list buffer or the script buffer, type M-C-v / M-C-y.</p>
<h3><a name="14.2" href="#14.2">14.2</a> <a name="label:75">Any ruby-mode buffer</a></h3><!-- RDLabel: "Any ruby-mode buffer" -->

<p>While the previous example uses the *ruby scratch* buffer as the script buffer, any ruby-mode buffer can be the script buffer.</p>
<h3><a name="14.3" href="#14.3">14.3</a> <a name="label:76">Error jump with eval list</a></h3><!-- RDLabel: "Error jump with eval list" -->

<p>If any errors are occurred during eval list execution, type</p>
<pre>C-c ` </pre>
<p>to jump to the error occurrence.</p>
<p>Here is an example,</p>
<pre>---- *ruby scratch*  (with line numbers)
1: def f(x)
2:   x ** 
3: end
4: 
5: def g(x)
6:   f(x)
7: end

---- *irbsh eval list*
g 1</pre>
<p>Type C-c C-z. Then irbsh displays error messages.</p>
<pre>irbsh[29@18:09](main):014:0&gt; 
SyntaxError: /home/rubikitch/.irbsh_eval_tmp:3: parse error
/home/rubikitch/.irbsh_eval_tmp:5: nested method definition
def g(x)
      ^
/home/rubikitch/.irbsh_eval_tmp:7: parse error
        from /home/rubikitch/src/irbsh/irbsh-lib.rb:418:in `load'
        from /home/rubikitch/src/irbsh/irbsh-lib.rb:418:in `irbsh_load_script_and_eval_eval_list'
        from (irbsh):14</pre>
<p>Note that /home/rubikitch/.irbsh_eval_tmp is a temporary script whose content is the script buffer.</p>
<p>Type C-c `, Then irbsh jumps the line 3.
One more, irbsh jumps the line 5.
One more, irbsh jumps the line 7.</p>
<p>C-c ` can accept numeric argument (C-u NUMBER C-c `).</p>
<h3><a name="14.4" href="#14.4">14.4</a> <a name="label:77">Load the script buffer only</a></h3><!-- RDLabel: "Load the script buffer only" -->

<p>C-u C-c C-z loads the script buffer.
It does not eval the eval list.</p>
<h3><a name="14.5" href="#14.5">14.5</a> <a name="label:78">$IRBSH global variable</a></h3><!-- RDLabel: "$IRBSH global variable" -->

<p>When irbsh is running, the global variable `$IRBSH' is true.
It is useful to use with eval list.</p>
<p>Typical usage is preparation for eval list.</p>
<pre>if $IRBSH
  # prepare for eval list
end</pre>
<h2><a name="15" href="#15">15</a> <a name="label:79">Oneliner</a></h2><!-- RDLabel: "Oneliner" -->

<p>Irbsh oneliner is so called Ruby version of M-! / M-:.
Default key bind is M-".</p>
<p>When you type M-", a prompt like this appears.</p>
<pre>Irbsh command [/home/rubikitch/src/irbsh]:</pre>
<p>Then you can input any Ruby expression(with irbsh extension).
When you type C-u M-", the evaluation result is inserted into current buffer.</p>
<h2><a name="16" href="#16">16</a> <a name="label:80">.irbshrc</a></h2><!-- RDLabel: ".irbshrc" -->

<p>`.irbshrc' is startup script of irbsh.
Normally when irb starts, it loads `.irbrc' as startup file.
When irbsh starts, it loads `.irbshrc' as well as `.irbrc'.</p>
<h3><a name="16.1" href="#16.1">16.1</a> <a name="label:81">Shell Aliases</a></h3><!-- RDLabel: "Shell Aliases" -->

<p>Irbsh can define shell aliases by `irbsh_alias' method.</p>
<pre>irbsh_alias ALIAS, DEFINITION</pre>
<p>Alias and definition are Symbol or String.</p>
<p>For example, you want to define `ls -F' as `lf',</p>
<pre>irbsh_alias :ls 'ls -F'</pre>
<p>or</p>
<pre>irbsh_alias 'ls', 'ls -F'</pre>
<h3><a name="16.2" href="#16.2">16.2</a> <a name="label:82">Prompt Customize</a></h3><!-- RDLabel: "Prompt Customize" -->

<p>Irb's prompt is customizable.
Irbsh provides prompt specification about current time as well as irb's prompt specification.</p>
<p>In the prompt specification, some special strings are available. </p>
<pre>%N    command name which is running
%m    to_s of main object (self)
%M    inspect of main object (self)
%l    type of string(", ', /, ]), `]' is inner %w[...]
%NNi  indent level. NN is degits and means as same as printf("%NNd"). 
      It can be ommited
%NNn  line number. 
%%    %
%D    year/month/day
%d    month/day
%T    hour:min:sec
%t    hour:min </pre>
<p>If you want simple prompt, append the following to `~/.irbshrc'.</p>
<pre>Irbsh.prompt = "%N(%m):%03n:%i&gt; "</pre>
<h3><a name="16.3" href="#16.3">16.3</a> <a name="label:83">pushdignoredups</a></h3><!-- RDLabel: "pushdignoredups" -->

<p>Like zsh's pushdignoredups, irbsh does not duplicate directories in the directory stack.</p>
<p>If you want to disable pushdignoredups feature, append the following to `~/.irbshrc'.</p>
<pre>Irbsh.disable_pushdignoredups</pre>
<p>If you want to enable it,</p>
<pre>Irbsh.enable_pushdignoredups</pre>
<h3><a name="16.4" href="#16.4">16.4</a> <a name="label:84">systemecho</a></h3><!-- RDLabel: "systemecho" -->

<p>Irbsh normally displays the command line when irbsh executes shell commands.
If you think it is verbose, add the following to `~/.irbshrc'.</p>
<pre>Irbsh.disable_systemecho</pre>
<p>You can enable it by  </p>
<pre>Irbsh.enable_systemecho</pre>
<h2><a name="17" href="#17">17</a> <a name="label:85">License</a></h2><!-- RDLabel: "License" -->

<p>GPL</p>

</body>
</html>
